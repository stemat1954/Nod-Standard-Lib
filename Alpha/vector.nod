
page vector in AlphaByNod


type vector<t><#n> from contiguous<<t>>
{{
	algebraic vector.
	
	numeric type <t> = int,	fp2, fp10, cplx

	<#n> dimension (number of coordinates)

	Affine matrix must have dims #r x #n where #r = #n + 1.
	Translation terms are in the last row.  Thus an affine
	transform post multiplies io by a given af_matrix after
	extending io with a value of one in the last coordinate.
	The value of #r can't be verified until runtime.
}}
{
	nom type same_type = vector<<t>><<#n>>;

	nom type sq_matrix = sq_matrix<<t>><<#n>>;  -- same dimensions as this vector

	nom type af_matrix<#r> = matrix<<t>><<#r>><<#n>>;  -- #r = #n + 1 (see notes)


	general method
	{
		begin;											-- zero vector

		begin ( same_type other );						-- copy

		begin<xt><#xn> ( vector<<xt>><<#xn>> other );	-- conversion 

		begin ( <t> x, <t> y, <t> z [opt], <t> w [opt] )()( extra );	-- synthesis

		begin<xt><c> ( sequential<<xt>><<c>> source );	-- fill


		begin ( mediator m [upd], expr fex )()( extra );	-- mediation

		store ( mediator m [upd], expr fex )()( extra );	-- mediation

	
		equal? ( same_type v )( bool );

		is_zero? ()( bool );


		set_coord [upd]( int i, <t> n );

		get_coord [eval]( int i )( <t> n );

		use_coord [eval]( int i ) = <t> proxy [eval,init];

		get_coords [eval]()( array<<t>><<#n>> );			


		add [upd]( same_type v );					-- add: io.xi := io.xi + v.xi 
		add [eval]( same_type v )( same_type v2 );		

		sub [upd]( same_type v );					-- subtract: io.xi := io.xi - v.xi 
		sub [eval]( same_type v )( same_type v2 );

		mul [upd]( <t> n );							-- multiply: io.xi := io.xi * n 
		mul [eval]( <t> n )( same_type v );

		div [upd]( <t> n );							-- divide: io.xi := io.xi / n 
		div [eval]( <t> n )( same_type v ); 

		neg [upd];									-- negate: io.xi := -io.xi 
		neg [eval]()( same_type v );

		dot [eval]( same_type v [opt] )( <t> n );	-- dot product: n := sum(io.xi * v.xi) ( default v = io )

		ltr [upd]( sq_matrix );						-- linear transform 
		ltr [eval]( sq_matrix )( same_type );	

		atr [upd]( sq_matrix, same_type t );		-- affine transform 
		atr [eval]( sq_matrix, same_type t )( same_type v );	

		atr<#r> [upd]( af_matrix<<#r>> );	   
		atr<#r> [eval]( af_matrix<<#r>> )( same_type v );	   
	}


	abstract method in contiguous<<t>>
	{
		[final]	~count ()( int q );					-- q := #n

		[final] ~use ( int i ) = <t> proxy;			-- use_coord(i)
	}

}

