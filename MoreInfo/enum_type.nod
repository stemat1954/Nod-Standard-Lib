
enum type foo ( 'a', 'b', 'c' );


type foo from enumerated  -- fabricated from enum type def
{{	
	The generated type definition for every enum
	type is source-identical except for the type name
	("foo" in this example).  However, each enum type 
	has it's own internal enumerator initialized for the
	enum type token set, so runtime results are unique 
	to the specific type.

	Note: An enum type name can't be generic, so the
	type name can be used in lieu of an object name.

	An enum type's code value can be used to compare 
	relative order and other arithmetic relationships. 
	However, note that the enumeration code can change 
	if the definition order is changed, so any code 
	that depends on definition order may be impacted 
	by an enum type change.

	Code that compares two enum types for equality and/or 
	evaluates them in a select instruction is safe.  That 
	is, new tokens can be added and reordered without
	affecting existing code because changes to the enum
	type definition will force recompilation.

}}
{
	general
	{
		begin ( expr ) -- vex
		{
			io:as_base<enumerated>:begin( near\$index:enumerate( given\expr )( =int ) );
			io.expr:begin( given\expr );
		}

		begin ( foo ) -- copy
		{
			io:as_base<enumerated>:begin( given\foo:as_int );
			io.expr:begin( given\foo.expr );
		}

		use_token = expr proxy [eval] ~t
		{
			~t -> io.expr;
		}

		get_token ()( expr )
		{
			given\expr:begin( io.expr );
		}

		is_before? ( foo )( bool )
		{
			io:use_code:is_before?( given\foo:use_code )( given\bool );
		}

		is_equal? ( foo )( bool )
		{
			io:use_code:is_equal?( given\foo:use_code )( given\bool );
		}
	}

	common <expr>enumerator $index;  -- initialized internally

	instance
	{
		expr;
	}
}

