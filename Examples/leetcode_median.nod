page leetcode_median in ExamplesByNod


subroutine find_median ( array<int> a, array<int> b )( fp2 m )
{{
	https://leetcode.com/problems/median-of-two-sorted-arrays/

	This subroutine iterates over two sorted input arrays, 
	logically merging them and returning the median value
	of the merged array as an output. A combined array is 
	never actually created because only a single value is 
	needed for the result.
	
	Since the arrays are sorted, it's an easy matter to 
	calculate the median index as "(n - 1) / 2" where n is
	combined array count. 

	When n is even, two values are needed to contribute to
	an average result, so the merge step is called a second
	time to get a second median.
}}
{
	a:count()( int qa );	-- quant a
	b:count()( int qb );	-- quant b
	int qab:begin( qa ):add( qb );  -- quant combined |>| zero

	int imax:begin( qa ):sub( one );  -- might be negative
	int jmax:begin( qb ):sub( one );  -- ditto
	int kmax:begin( qab ):sub( one ):div( two );  -- median, not negative

	merge ( a, b, imax, jmax, kmax, *int i:begin, *int j:begin, *int k:begin )( int n );
	m:begin( n );
	if ( qab:mod( two ):equal?( zero )( =bool ) )  -- if even, "mod( qab, two ) |=| zero" 
	{
		merge ( a, b, imax, jmax, kmax:inc, *i, *j, *k:inc )( n:recycle );
		m:add( n ):div( two );
	}
}


[page] subroutine merge ( array<int> a, array<int> b, int imax, int jmax, int kmax, int i [upd], int j [upd], int k [upd] )( int n )
{
	loop ( "k |<=| kmax" ) 
	{
		n:recycle;
		if ( "i |>| imax" )
		{
			n:begin( b:use( j ) );
			j:inc;
		}
		else if ( "j |>| jmax" )
		{
			n:begin( a:use( i ) );
			i:inc;
		}
		else
		{
			a:use( i ) is ~an;
			b:use( j ) is ~bn;
			if ( "~an |<=| ~bn" )
			{
				n:begin( ~an );
				i:inc;
			}
			else
			{
				n:begin( ~bn );
				j:inc;
			}
		}
		k:inc;
	}
}

