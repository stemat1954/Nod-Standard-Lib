page leetcode_index in ExamplesByNod

subroutine index_substrings ( string s, array<string> match )( array<int> map )
{{
	https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/

	Find substrings in s where substrings are formed by permuting
	and combining fixed length strings in match. The strings in 
	match are equal length and every combination is comprised of
	every match string.

	The position index of each substring is added to output map.

	zero length cases are ruled out by problem description.

	The solution parses the input string into a token array and
	then walks though the token array trying to match the token
	sequence to match strings.
}}
{
	match:use( zero ):get_length()( int unit ); -- unit length

	parse( s, unit )( array<string> tokens );

	match:count()( int extent ); -- number of units to compare

	map:begin;

	int i:begin;
	tokens:count()( =int imax ):sub( extent );  -- imax may be negative

	loop ( "i |<=| imax" )
	{
		compare ( i, extent, tokens, match, *map );
		i:inc;
	}
}


[page] subroutine parse ( string s, int q )( array<string> tokens ) 
{{ 
	parse input s into fixed q-length tokens 
}}
{
	int i:begin;
	s:get_length()( int ilim ); 
	loop
	{
		s:extract( i, q )( tokens:insert );
		if ( i:add( q ):less?( ilim )( =bool ):not ) return;  -- when new i >= lim
	}
}


[page] subroutine compare ( int i, int q, array<string> tokens, array<string> match, array<int> map [upd] )
{{
	If all q tokens starting at i are in match, add i to map.

	Caller is responsible for valid i and q, such that token 
	at i + q - 1 exists.
}}
{
	int j:begin( i );
	int jlim:begin( j ):add( q );
	loop ( "j |<| jlim" )
	{
		match?( tokens:use( j ), match )( bool yes );
		if ( yes:not ) return;
		j:inc;
	}
	map:insert:begin( i );
}


[page] subroutine match? ( string token, array<string> match )( bool yes )
{
	yes:begin( 'true' ); 
	for each ( ~s in match ) if ( "token |=| ~s" ) return; -- yes is true
	yes <= false; 
}

